# -*- coding: utf-8 -*-
"""PRML_assignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v9gCpXcxX9nJ_9IUWsEu3KuF7sedKhKI

Authors:
V S S Anirudh Sharma, EE18B036
Hema Landa, EE19B036  
"""# BAYESIAN CLASSIFICATION"""

import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import DetCurveDisplay, ConfusionMatrixDisplay, confusion_matrix
import sys


def Extract(filename):
  f = open(filename, "r")
  data= f.readlines()
  f.close()

  Xtrain = []
  Class = []
  for d in data:
    X,Y,C= map(float,d[:].split(','))
    Xtrain.append([X,Y])
    Class.append(C)
  Xtrain = np.array(Xtrain).T
  Class = np.array(Class)
  return Xtrain,Class

try:
  Xtrain,Class = Extract(sys.argv[1])
  Xdev, Class_dev = Extract(sys.argv[2])
except:
  print('Invalid arguments')
  exit()

markers = ["." , "+" , "v"]

plt.figure(figsize=(10,10))
for i in [1,2,3]:  
  plt.scatter(Xtrain[0,np.where(Class == i)],Xtrain[1,np.where(Class == i)],label = 'Actual class {}'.format(i), s = 50,marker = markers[i-1])
plt.legend()
plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Train data with actual classes')

plt.figure(figsize=(10,10))
for i in [1,2,3]:  
  plt.scatter(Xdev[0,np.where(Class_dev == i)],Xdev[1,np.where(Class_dev == i)],label = 'Actual class {}'.format(i), s = 50,marker = markers[i-1])
plt.legend()
plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Dev data with actual classes')

color = {1:'r',2:'g',3:'b'}

"""# General 


"""

Xt = {i:Xtrain[:,np.where(Class == i)].reshape(2,-1) for i in range(1,4)}

Pw = {i:Xt[i].shape[1]/Xtrain.shape[1] for i in range(1,4)}

Mu = {i: np.mean(Xt[i], axis = 1) for i in [1,2,3]}

def score(x,mu,Cov,Pw = 1/3,d = 2):
  #np.log(Pw[i])-0.5*(x-mu[i]).T@np.linalg.inv(Cov[i])@(x-mu[i])-np.log(np.linalg.det(Cov[i]))*d/4
  return Pw*(np.exp(-0.5*(x-mu).T@np.linalg.inv(Cov)@(x-mu)))/(np.sqrt((2*np.pi)**d*np.linalg.det(Cov)))

def ROC_DET(Covs,X = Xdev,Y=Class_dev,Mus = Mu,Pw = Pw,N = 100,d = 2,Nclass = 3):
  Smin = 0
  Smax = min([Pw[i]/(np.sqrt((2*np.pi)**d*np.linalg.det(Covs[i]))) for i in range(1,Nclass+1)])
  TPR = []; FPR = [];FNR = []
  for thresh in np.linspace(Smin,Smax,N):
    TP = FN = TN = FP = 0;
    for x,y in zip(X[:,:].T,Y):
      for i in range(1,Nclass+1):
        if score(x,Mus[i],Covs[i],Pw[i],d) >= thresh:
          if y==i:
            TP+=1
          else:
            FP+=1
        else:
          if y==i:
            FN+=1
          else:
            TN+=1
    TPR.append(TP/(TP+FN))
    FPR.append(FP/(FP+TN))
    FNR.append(FN/(TP+FN))
  return TPR,FPR,FNR




n = 200
d = 2
f = 0.6
Xmin = np.min(Xtrain[0,:]); Xmax = np.max(Xtrain[0,:]); 
Ymin = np.min(Xtrain[1,:]); Ymax = np.max(Xtrain[1,:]);
Dx = Xmax-Xmin; Dy = Ymax-Ymin; 
MidX = (Xmin+Xmax)/2; MidY = (Ymin+Ymax)/2;
Xmin = MidX-f*Dx; Xmax = MidX+f*Dx;
Ymin = MidY-f*Dy; Ymax = MidY+f*Dy;
x = np.linspace(Xmin,Xmax,n)
y = np.linspace(Ymin,Ymax,n)
X,Y = np.meshgrid(x,y)

"""# Case 1"""

def Case1(X,Pw,mu,Cov):
  Class = []
  for x in X[:,:].T:
    g = {i: np.log(Pw[i])-0.5*(x-mu[i]).T@np.linalg.inv(Cov)@(x-mu[i]) for i in [1,2,3]}
    Class.append(max(g, key=g.get))
  return np.array(Class)

#Cov_all = np.cov(Xtrain,ddof=0)
#Cov_all = (np.cov(Xt[1],ddof=0)*Pw[1] + np.cov(Xt[2],ddof=0)*Pw[2] + np.cov(Xt[3],ddof=0)*Pw[3])
Cov_all = sum([np.cov(Xt[i],ddof=0)*Pw[i] for i in [1,2,3]])
CovTemp1 = {i:Cov_all for i in [1,2,3]}

Z1 = np.zeros((n,n))
S1 = {i:np.zeros((n,n)) for i in [1,2,3]}
for i in range(n):
  for j in range(n):
    x = np.array([X[i,j],Y[i,j]])
    g = {i: np.log(Pw[i])-0.5*(x-Mu[i]).T@np.linalg.inv(Cov_all)@(x-Mu[i]) for i in [1,2,3]}
    Z1[i,j] = max(g, key=g.get)
    for clas in [1,2,3]:
      S1[clas][i,j] = score(x,Mu[clas],CovTemp1[clas],Pw[clas])/Pw[clas]

plt.figure(figsize = (10,10))
plt.pcolormesh(X,Y,Z1,shading='auto')
for i in [1,2,3]:  
  plt.scatter(Xtrain[0,np.where(Class == i)],Xtrain[1,np.where(Class == i)],label = 'Actual class {}'.format(i), s = 50,marker = markers[i-1])
  plt.contour(X,Y, S1[i])
  W,V = np.linalg.eig(CovTemp1[i])
  plt.arrow(Mu[i][0],Mu[i][1],V[0,0]*10,V[1,0]*10)
  plt.arrow(Mu[i][0],Mu[i][1],V[0,1]*10,V[1,1]*10)
plt.legend()
plt.xlabel('X1')
plt.ylabel('Y1')
plt.title('Case 1 Prediction over test data', fontsize=20)

cmaps = ['OrRd','PuBu','YlGn']

fig = plt.figure(figsize = (10,10))
ax = plt.axes(projection='3d')
ax.plot_surface(X,Y,-np.ones_like(X)*max([np.max(S1[clas]) for clas in [1,2,3]]), cstride=1, rstride=1, facecolors=np.vectorize(color.get)(Z1))
for clas in [1,2,3]:
    c = ax.plot_surface(X, Y, (S1[clas]), color=color[clas],alpha = 0.5,label = 'Class {}'.format(clas))
    c._facecolors2d=c._facecolors3d
    c._edgecolors2d=c._edgecolors3d

plt.legend()
plt.title('Plotting the PDFs: Case 1',fontsize=20)
ax.view_init(30, 30)


Class_fit1_tra = Case1(Xtrain,Pw,Mu,Cov_all)
Class_fit1_dev = Case1(Xdev,Pw,Mu,Cov_all)

Ctra1 = confusion_matrix(Class, Class_fit1_tra)
Cdev1 = confusion_matrix(Class_dev, Class_fit1_dev)

ConfusionMatrixDisplay(confusion_matrix=Ctra1,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(TRAIN) CASE 1')

ConfusionMatrixDisplay(confusion_matrix=Cdev1,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(DEV) CASE 1')

TPR1,FPR1,FNR1 = ROC_DET(CovTemp1)

plt.figure(figsize=(10,10))
plt.plot(FPR1,TPR1)
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC for Case 1')

DetCurveDisplay(fpr=FPR1, fnr=FNR1, estimator_name="CASE 1").plot()

"""# Case 2"""

def Case2(X,Pw,mu,Cov,d=2):
  Class = []
  for x in X[:,:].T:
    g = {i: np.log(Pw[i])-0.5*(x-mu[i]).T@np.linalg.inv(Cov[i])@(x-mu[i])-np.log(np.linalg.det(Cov[i]))*d/4 for i in [1,2,3]}
    Class.append(max(g, key=g.get))
  return np.array(Class)

Covs = {i : np.cov(Xt[i],ddof=0) for i in [1,2,3]}

CovTemp2 = Covs

Z2 = np.zeros((n,n))
S2 = {i:np.zeros((n,n)) for i in [1,2,3]}
for i in range(n):
  for j in range(n):
    x = np.array([X[i,j],Y[i,j]])
    g = {i: np.log(Pw[i])-0.5*(x-Mu[i]).T@np.linalg.inv(Covs[i])@(x-Mu[i])-np.log(np.linalg.det(Covs[i]))*d/4 for i in [1,2,3]}
    Z2[i,j] = max(g, key=g.get)
    for clas in [1,2,3]:
      S2[clas][i,j] = score(x,Mu[clas],CovTemp2[clas],Pw[clas])/Pw[clas]

plt.figure(figsize=(10,10))
plt.pcolormesh(X,Y,Z2,shading='auto')
#for i in [1,2,3]:
  #plt.scatter(Xdev[0,np.where(Class_fit2_dev == i)],Xdev[1,np.where(Class_fit2_dev == i)],label = 'Predicted class {}'.format(i),alpha = 0.5, s= 100)
for i in [1,2,3]:  
  plt.scatter(Xtrain[0,np.where(Class == i)],Xtrain[1,np.where(Class == i)],label = 'Actual class {}'.format(i), s = 50,marker = markers[i-1])
  plt.contour(X,Y, S2[i])
  W,V = np.linalg.eig(CovTemp2[i])
  plt.arrow(Mu[i][0],Mu[i][1],V[0,0]*10,V[1,0]*10)
  plt.arrow(Mu[i][0],Mu[i][1],V[0,1]*10,V[1,1]*10)
plt.legend()

plt.xlabel('X1')
plt.ylabel('Y1')
plt.title('Case 2 Prediction over test data', fontsize=20)

fig = plt.figure(figsize = (10,10))
ax = plt.axes(projection='3d')
ax.plot_surface(X,Y,-np.ones_like(X)*max([np.max(S2[clas]) for clas in [1,2,3]]), cstride=1, rstride=1, facecolors=np.vectorize(color.get)(Z2))
for clas in [1,2,3]:
    c = ax.plot_surface(X, Y, (S2[clas]), color=color[clas],alpha = 0.5,label = 'Class {}'.format(clas))
    c._facecolors2d=c._facecolors3d
    c._edgecolors2d=c._edgecolors3d
plt.legend()
plt.title('Plotting the PDFs: Case 2',fontsize=20)
ax.view_init(30, 30)

Class_fit2_tra = Case2(Xtrain,Pw,Mu,Covs)
Class_fit2_dev = Case2(Xdev,Pw,Mu,Covs)

Ctra2 = confusion_matrix(Class, Class_fit2_tra)
Cdev2 = confusion_matrix(Class_dev, Class_fit2_dev)

ConfusionMatrixDisplay(confusion_matrix=Ctra2,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(TEST) CASE 2')

ConfusionMatrixDisplay(confusion_matrix=Cdev2,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(DEV) CASE 2')

TPR2,FPR2,FNR2 = ROC_DET(CovTemp2)

plt.figure(figsize=(10,10))
plt.plot(FPR2,TPR2)
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC for Case 2')

DetCurveDisplay(fpr=FPR2, fnr=FNR2, estimator_name="CASE 2").plot()

"""# CASE 3"""

def Case3(X,Pw,mu,var):
  Class = []
  for x in X[:,:].T:
    g = {i: np.log(Pw[i])-0.5*np.sum((x-mu[i])**2)/var for i in [1,2,3]}
    Class.append(max(g, key=g.get))
  return np.array(Class)

#var = sum([np.var(Xt[i])*Pw[i] for i in [1,2,3]])
var = sum([sum(np.var(Xt[i][j,:])/d for j in range(d))*Pw[i] for i in [1,2,3]])

CovTemp3 = {i:var*np.eye(d) for i in [1,2,3]}

Z3 = np.zeros((n,n))
S3 = {i:np.zeros((n,n)) for i in [1,2,3]}
for i in range(n):
  for j in range(n):
    x = np.array([X[i,j],Y[i,j]])
    g = {i: np.log(Pw[i])-0.5*np.sum((x-Mu[i])**2)/var for i in [1,2,3]}
    Z3[i,j] = max(g, key=g.get)
    for clas in [1,2,3]:
      S3[clas][i,j] = score(x,Mu[clas],CovTemp3[clas],Pw[clas])/Pw[clas]

plt.figure(figsize=(10,10))
plt.pcolormesh(X,Y,Z3,shading='auto')
#for i in [1,2,3]:
  #plt.scatter(Xdev[0,np.where(Class_fit3_dev == i)],Xdev[1,np.where(Class_fit3_dev == i)],label = 'Predicted class {}'.format(i), alpha = 0.5, s= 100)
for i in [1,2,3]:  
  plt.scatter(Xtrain[0,np.where(Class == i)],Xtrain[1,np.where(Class == i)],label = 'Actual class {}'.format(i), s = 50,marker = markers[i-1])
  plt.contour(X,Y, S3[i])
  W,V = np.linalg.eig(CovTemp3[i])
  plt.arrow(Mu[i][0],Mu[i][1],V[0,0]*10,V[1,0]*10)
  plt.arrow(Mu[i][0],Mu[i][1],V[0,1]*10,V[1,1]*10)
plt.legend()
plt.xlabel('X1')
plt.ylabel('Y1')
plt.title('Case 3 Prediction over test data', fontsize=20)

fig = plt.figure(figsize = (10,10))
ax = plt.axes(projection='3d')
ax.plot_surface(X,Y,-np.ones_like(X)*max([np.max(S3[clas]) for clas in [1,2,3]]), cstride=1, rstride=1, facecolors=np.vectorize(color.get)(Z3))
for clas in [1,2,3]:
    c = ax.plot_surface(X, Y, (S3[clas]), color=color[clas],alpha = 0.5,label = 'Class {}'.format(clas))
    c._facecolors2d=c._facecolors3d
    c._edgecolors2d=c._edgecolors3d
plt.legend()
plt.title('Plotting the PDFs: Case 3',fontsize=20)
ax.view_init(30, 30)


Class_fit3_tra = Case3(Xtrain,Pw,Mu,var)
Class_fit3_dev = Case3(Xdev,Pw,Mu,var)

Ctra3 = confusion_matrix(Class, Class_fit3_tra)
Cdev3 = confusion_matrix(Class_dev, Class_fit3_dev)

ConfusionMatrixDisplay(confusion_matrix=Ctra3,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(TEST) CASE 3')

ConfusionMatrixDisplay(confusion_matrix=Cdev3,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(DEV) CASE 3')

TPR3,FPR3,FNR3 = ROC_DET(CovTemp3)

plt.figure(figsize=(10,10))
plt.plot(FPR3,TPR3)
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC for Case 3')

DetCurveDisplay(fpr=FPR3, fnr=FNR3, estimator_name="CASE 3").plot()

"""# CASE 4"""

def Case4(X,Pw,mu,vars):
  Class = []
  for x in X[:,:].T:
    g = {i: np.log(Pw[i])-0.5*(x-mu[i]).T@np.diag(1/vars)@(x-mu[i]) for i in [1,2,3]}
    Class.append(max(g, key=g.get))
  return np.array(Class)

vars = np.array([sum([np.var(Xt[i][j,:])*Pw[i] for i in [1,2,3]]) for j in range(2)])

CovTemp4 = {i:np.diag(vars) for i in [1,2,3]}

Z4 = np.zeros((n,n))
S4 = {i:np.zeros((n,n)) for i in [1,2,3]}
for i in range(n):
  for j in range(n):
    x = np.array([X[i,j],Y[i,j]])
    g = {i: np.log(Pw[i])-0.5*(x-Mu[i]).T@np.diag(1/vars)@(x-Mu[i]) for i in [1,2,3]}
    Z4[i,j] = max(g, key=g.get)
    for clas in [1,2,3]:
      S4[clas][i,j] = score(x,Mu[clas],CovTemp4[clas],Pw[clas])/Pw[clas]

plt.figure(figsize=(10,10))
plt.pcolormesh(X,Y,Z4,shading='auto')
#for i in [1,2,3]:
  #plt.scatter(Xdev[0,np.where(Class_fit4_dev == i)],Xdev[1,np.where(Class_fit4_dev == i)],label = 'Predicted class {}'.format(i), alpha = 0.5, s= 100)
for i in [1,2,3]:  
  plt.scatter(Xtrain[0,np.where(Class == i)],Xtrain[1,np.where(Class == i)],label = 'Actual class {}'.format(i), s = 50,marker = markers[i-1])
  plt.contour(X,Y, S4[i])
  W,V = np.linalg.eig(CovTemp4[i])
  plt.arrow(Mu[i][0],Mu[i][1],V[0,0]*10,V[1,0]*10)
  plt.arrow(Mu[i][0],Mu[i][1],V[0,1]*10,V[1,1]*10)
plt.legend()
plt.xlabel('X1')
plt.ylabel('Y1')
plt.title('Case 4 Prediction over test data', fontsize=20)

fig = plt.figure(figsize = (10,10))
ax = plt.axes(projection='3d')
ax.plot_surface(X,Y,-np.ones_like(X)*max([np.max(S4[clas]) for clas in [1,2,3]]), cstride=1, rstride=1, facecolors=np.vectorize(color.get)(Z4))
for clas in [1,2,3]:
    c = ax.plot_surface(X, Y, (S4[clas]), color=color[clas],alpha = 0.5,label = 'Class {}'.format(clas))
    c._facecolors2d=c._facecolors3d
    c._edgecolors2d=c._edgecolors3d
plt.legend()
plt.title('Plotting the PDFs: Case 4',fontsize=20)
ax.view_init(30, 30)

Class_fit4_tra = Case4(Xtrain,Pw,Mu,vars)
Class_fit4_dev = Case4(Xdev,Pw,Mu,vars)

Ctra4 = confusion_matrix(Class, Class_fit4_tra)
Cdev4 = confusion_matrix(Class_dev, Class_fit4_dev)

ConfusionMatrixDisplay(confusion_matrix=Ctra4,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(TEST) CASE 4')

ConfusionMatrixDisplay(confusion_matrix=Cdev4,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(DEV) CASE 4')

TPR4,FPR4,FNR4 = ROC_DET(CovTemp4)

plt.figure(figsize=(10,10))
plt.plot(FPR4,TPR4)
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC for Case 4')

DetCurveDisplay(fpr=FPR4, fnr=FNR4, estimator_name="CASE 4").plot()

"""# Case 5"""

def Case5(X,Pw,mu,varses):
  Class = []
  for x in X[:,:].T:
    g = {i: np.log(Pw[i])-0.5*(x-mu[i]).T@np.diag(1/varses[i])@(x-mu[i]) for i in [1,2,3]}
    Class.append(max(g, key=g.get))
  return np.array(Class)

varses = {i: np.array([np.var(Xt[i][j,:]) for j in range(2)]) for i in [1,2,3]}

CovTemp5 = {i:np.diag(varses[i]) for i in [1,2,3]}

Z5 = np.zeros((n,n))
S5 = {i:np.zeros((n,n)) for i in [1,2,3]}
for i in range(n):
  for j in range(n):
    x = np.array([X[i,j],Y[i,j]])
    g = {i: np.log(Pw[i])-0.5*(x-Mu[i]).T@np.diag(1/varses[i])@(x-Mu[i]) for i in [1,2,3]}
    Z5[i,j] = max(g, key=g.get)
    for clas in [1,2,3]:
      S5[clas][i,j] = score(x,Mu[clas],CovTemp5[clas],Pw[clas])/Pw[clas]

plt.figure(figsize=(10,10))
plt.pcolormesh(X,Y,Z5,shading='auto')
#for i in [1,2,3]:
  #plt.scatter(Xdev[0,np.where(Class_fit5_dev == i)],Xdev[1,np.where(Class_fit5_dev == i)],label = 'Predicted class {}'.format(i), alpha = 0.5, s= 100)
for i in [1,2,3]:  
  plt.scatter(Xtrain[0,np.where(Class == i)],Xtrain[1,np.where(Class == i)],label = 'Actual class {}'.format(i), s = 50,marker = markers[i-1])
  plt.contour(X,Y, S5[i])
  W,V = np.linalg.eig(CovTemp5[i])
  plt.arrow(Mu[i][0],Mu[i][1],V[0,0]*10,V[1,0]*10)
  plt.arrow(Mu[i][0],Mu[i][1],V[0,1]*10,V[1,1]*10)
plt.legend()
plt.xlabel('X1')
plt.ylabel('Y1')
plt.title('Case 5 Prediction over test data', fontsize=20)

fig = plt.figure(figsize = (10,10))
ax = plt.axes(projection='3d')
ax.plot_surface(X,Y,-np.ones_like(X)*max([np.max(S5[clas]) for clas in [1,2,3]]), cstride=1, rstride=1, facecolors=np.vectorize(color.get)(Z5))
for clas in [1,2,3]:
    c = ax.plot_surface(X, Y, (S5[clas]), color=color[clas],alpha = 0.5,label = 'Class {}'.format(clas))
    c._facecolors2d=c._facecolors3d
    c._edgecolors2d=c._edgecolors3d
plt.legend()
plt.title('Plotting the PDFs: Case 5',fontsize=20)
ax.view_init(30, 30)


Class_fit5_tra = Case5(Xtrain,Pw,Mu,varses)
Class_fit5_dev = Case5(Xdev,Pw,Mu,varses)

Ctra5 = confusion_matrix(Class, Class_fit5_tra)
Cdev5 = confusion_matrix(Class_dev, Class_fit5_dev)

ConfusionMatrixDisplay(confusion_matrix=Ctra5,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(TEST) CASE 5')

ConfusionMatrixDisplay(confusion_matrix=Cdev5,display_labels=['Class 1','Class 2','Class 3']).plot()
plt.title('Confusion Matrix:(DEV) CASE 5')

TPR5,FPR5,FNR5 = ROC_DET(CovTemp5)

plt.figure(figsize=(10,10))
plt.plot(FPR5,TPR5)
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC for Case 5')

DetCurveDisplay(fpr=FPR5, fnr=FNR5, estimator_name="CASE 5").plot()

"""# Comparing models from ROC and DET"""

plt.figure(figsize=(10,10))
plt.plot(FPR1,TPR1,label = 'Case 1')
plt.plot(FPR2,TPR2,label = 'Case 2')
plt.plot(FPR3,TPR3,label = 'Case 3')
plt.plot(FPR4,TPR4,label = 'Case 4')
plt.plot(FPR5,TPR5,label = 'Case 5')
plt.plot(np.linspace(0,1,100),np.linspace(0,1,100),linestyle='--', label = 'Random prediction')
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC curve for different cases')
plt.legend()

fig, ax_det = plt.subplots(1,1,figsize=(10, 10))
DetCurveDisplay(fpr=FPR1, fnr=FNR1, estimator_name="CASE 1").plot(ax = ax_det)
DetCurveDisplay(fpr=FPR2, fnr=FNR2, estimator_name="CASE 2").plot(ax = ax_det)
DetCurveDisplay(fpr=FPR3, fnr=FNR3, estimator_name="CASE 3").plot(ax = ax_det)
DetCurveDisplay(fpr=FPR4, fnr=FNR4, estimator_name="CASE 4").plot(ax = ax_det)
DetCurveDisplay(fpr=FPR5, fnr=FNR5, estimator_name="CASE 5").plot(ax = ax_det)
ax_det.set_title('DET curve for different cases')



plt.show()
